<!DOCTYPE html>
<html lang='en'>
<head>
<meta charset='utf-8'>
<title>Employment FTW District</title>
<meta name='viewport' content='width=device-width, initial-scale=1'>
<link href='https://fonts.googleapis.com/css2?family=IBM+Plex+Sans:wght@400;600;700&display=swap' rel='stylesheet'>
<script src='https://cdnjs.cloudflare.com/ajax/libs/d3/7.9.0/d3.min.js'></script>
<style>
  html, body { margin: 0; padding: 0; height: 100%; font-family: 'IBM Plex Sans', sans-serif; background:#fff; }
  .chart-wrap { width: 90%; height: 100vh; margin: 0px auto}
  svg { width: 100%; height: 100%; background: transparent; display: block; }
  .y-axis, .y-axis path, .y-axis .tick line, .y-axis .domain { display: none; }
  .marker { fill: #fff; stroke: #196533; }
  .label-fw rect { fill: #196533; }
  .label-fw text { fill: #fff; font-weight: 600; }
  .label-sw { fill: #196533; font-weight: 700; }
  .growth { fill: #196533; font-weight: 700; }
  .ref-line { stroke: #196533; }
  .hover-line { stroke: rgba(25,101,51,0.5); pointer-events: none; }
  .tooltip { position: absolute; pointer-events: none; background: #fff; border: 1px solid #ccc; display: none; }
</style>
</head>
<body>
<div class='chart-wrap'>
  <svg id='chart' preserveAspectRatio='xMidYMid meet'></svg>
  <div class='tooltip' id='tooltip'></div>
</div>
<script>
const url = 'https://pine-j.github.io/FDTMP_WebAPP/ChartData/FDTMP_Employment_District.csv';
const GREEN = '#196533';
const markerYears = [2000,2010,2020,2024,2030,2040,2050];
const labelYears = [2000,2024,2050];
const projectionStart = 2024;
const svg = d3.select('#chart');
const tooltip = d3.select('#tooltip');

// Use the same options for both formatting and rounding,
// so labels and growth match visually and numerically.
const COMPACT_OPTS = {
  rawMaxDecimals: 1,  // raw (<1K)
  kDecimals: 1,       // <1M
  mDecimals: 1,       // <1B
  bDecimals: 1,       // >=1B
  trimZeros: true,
  useGrouping: false
};

// Conventional compact formatter: <1K raw, <1M K, <1B M, >=1B B
function formatCompact(n, {
  rawMaxDecimals = 1,
  kDecimals = 1,
  mDecimals = 1,
  bDecimals = 1,
  trimZeros = true,
  useGrouping = false,
} = {}) {
  if (n == null || !isFinite(n)) return '';

  const abs = Math.abs(n);
  const sign = n < 0 ? -1 : 1;
  const trim = s => trimZeros ? s.replace(/\.0+$|(\.\d*[1-9])0+$/, '$1') : s;
  const toFixed = (val, decimals) => trim(val.toFixed(decimals));
  const group = new Intl.NumberFormat(undefined, { useGrouping }).format;

  if (abs < 1_000) {
    if (Number.isInteger(n)) return useGrouping ? group(n) : String(n);
    return trim(n.toFixed(Math.min(rawMaxDecimals, 6)));
  }
  if (abs < 1_000_000) return `${toFixed(sign * abs / 1_000, kDecimals)}K`;
  if (abs < 1_000_000_000) return `${toFixed(sign * abs / 1_000_000, mDecimals)}M`;
  return `${toFixed(sign * abs / 1_000_000_000, bDecimals)}B`;
}


function formatPercent(p){ return Math.round(p)+'%'; }
function getValueAt(series,year){
  const i = d3.bisector(d => d.year).left(series, year);
  if(i < series.length && series[i].year === year) return series[i].value;
  const i1 = Math.max(0, i-1), i2 = Math.min(series.length-1, i);
  const a = series[i1], b = series[i2];
  if(!a || !b) return null;
  const t = (year - a.year) / (b.year - a.year);
  return a.value + t * (b.value - a.value);
}

function render(raw){
  svg.selectAll('*').remove();
  const container = document.querySelector('.chart-wrap');
  const width = container.clientWidth;
  const height = container.clientHeight || 500;

  // Base design size, elements scale relative to this
  const DESIGN_W = 900, DESIGN_H = 520;
  const s = Math.min(width / DESIGN_W, height / DESIGN_H);

  // Helper: scale size with a floor (minimum in px)
  const sz = (base, minPx) => Math.max(minPx, base * s);

  // ---- Visual sizing ----
  const margin = { top: 90*s, right: 30*s, bottom: 50*s, left: 40*s };

  // Fonts with minimums
  const AXIS_FZ   = sz(15, 17);  // axis tick labels (min 11px)
  const LEGEND_FZ = sz(16, 18);  // legend text (min 12px)
  const LABEL_FZ  = sz(16, 18);  // value labels (min 12px)
  const GROWTH_FZ = sz(16, 18);  // growth % labels (min 12px)
  const TIP_FZ    = sz(15, 17);  // tooltip font (min 11px)

  // Other visuals
  const FW_WIDTH = 8*s, SW_WIDTH = 2*s, MARKER_R = 5*s;
  const PILL_PAD_X = 8*s, PILL_PAD_Y = 5*s, PILL_RX = 4*s;
  const LEGEND_X2 = 36*s, LEGEND_TEXT_X = 44*s;
  const REF_WIDTH = 1.5*s;
  const DASH = `${5*s} ${4*s}`;

  // Offsets tied to font sizes so spacing stays reasonable when floors kick in
  const LABEL_OFF_FW = 1.2 * LABEL_FZ; // ~18px at base
  const LABEL_OFF_SW = 0.95 * LABEL_FZ; // ~14px at base
  const GROWTH_OFF   = 1.45 * GROWTH_FZ; // ~22px at base
  const LEGEND_Y_GAP = LEGEND_FZ * (20/14); // proportional to legend text size

  svg.attr('viewBox', `0 0 ${width} ${height}`);

  const data = raw;
  const fwSeries = data.map(d => ({year: +d.Year, value: +d['Fort Worth']})).sort((a,b) => a.year - b.year);
  const swSeries = data.map(d => ({year: +d.Year, value: +d.Statewide})).sort((a,b) => a.year - b.year);

  const x = d3.scaleLinear().domain([2000,2050]).range([margin.left, width - margin.right]);
  const y = d3.scaleLinear().domain(d3.extent([...fwSeries.map(d => d.value), ...swSeries.map(d => d.value)])).nice().range([height - margin.bottom, margin.top]);

  // X axis with scaled font-size and a minimum
  const xAxis = d3.axisBottom(x).tickValues(markerYears.filter(y => y !== 2024)).tickFormat(d3.format('d'));
  const gx = svg.append('g').attr('class','x-axis').attr('transform',`translate(0,${height - margin.bottom})`).call(xAxis);
  gx.selectAll('text').style('font-size', `${AXIS_FZ}px`);

  // --- LAYERS ---
  const guides = svg.append('g').attr('class','guides'); // behind series
  const seriesG = svg.append('g').attr('class','series'); // lines on top of guides
  const overlayG = svg.append('g').attr('class','overlay'); // markers/labels/legend on top of series

  // Reference line at 2024 from max(FW,SW) down to axis (in guides layer)
  const valFW2024 = getValueAt(fwSeries, 2024);
  const valSW2024 = getValueAt(swSeries, 2024);
  const maxVal2024 = Math.max(valFW2024, valSW2024);
  guides.append('line')
    .attr('class','ref-line')
    .attr('x1', x(2024)).attr('x2', x(2024))
    .attr('y1', y(maxVal2024)).attr('y2', height - margin.bottom)
    .attr('stroke-width', REF_WIDTH)
    .attr('stroke-dasharray', DASH);

  // --- Hover vertical dotted line (in guides layer; lighter color) ---
  const hoverLine = guides.append('line')
    .attr('class','hover-line')
    .attr('y1', margin.top)
    .attr('y2', height - margin.bottom)
    .attr('stroke', 'rgba(25,101,51,0.5)')
    .attr('stroke-width', REF_WIDTH)
    .attr('stroke-dasharray', DASH)
    .style('opacity', 0);

  const line = d3.line().x(d => x(d.year)).y(d => y(d.value)).curve(d3.curveMonotoneX);

  function drawSeries(series, isFW){
    const solid = series.filter(d => d.year <= projectionStart);
    const dotted = series.filter(d => d.year >= projectionStart);
    seriesG.append('path').attr('fill','none').attr('stroke', GREEN).attr('stroke-width', isFW ? FW_WIDTH : SW_WIDTH).attr('d', line(solid));
    seriesG.append('path').attr('fill','none').attr('stroke', GREEN).attr('stroke-width', isFW ? FW_WIDTH : SW_WIDTH).attr('stroke-dasharray', DASH).attr('d', line(dotted));
  }
  drawSeries(fwSeries, true);
  drawSeries(swSeries, false);

  function drawMarkers(series){
    markerYears.forEach(yr => {
      const val = getValueAt(series, yr);
      if(val != null){
        overlayG.append('circle')
          .attr('class','marker')
          .attr('r', MARKER_R)
          .attr('cx', x(yr))
          .attr('cy', y(val))
          .attr('stroke-width', Math.max(1, 2*s));
      }
    });
  }
  drawMarkers(fwSeries);
  drawMarkers(swSeries);

  // Legend (scaled spacing and font with minimum) – in overlayG
  const legend = overlayG.append('g').attr('class','legend').attr('transform',`translate(${margin.left + 10*s}, ${margin.top - 50*s})`);
  legend.append('line').attr('x1',0).attr('x2',LEGEND_X2).attr('y1',0).attr('y2',0).attr('stroke',GREEN).attr('stroke-width',FW_WIDTH);
  legend.append('text').attr('x',LEGEND_TEXT_X).attr('y',0 + 0.285*LEGEND_FZ)
        .style('font-size', `${LEGEND_FZ}px`).text('Fort Worth District');
  legend.append('line').attr('x1',0).attr('x2',LEGEND_X2).attr('y1',LEGEND_Y_GAP).attr('y2',LEGEND_Y_GAP).attr('stroke',GREEN).attr('stroke-width',SW_WIDTH);
  legend.append('text').attr('x',LEGEND_TEXT_X).attr('y',LEGEND_Y_GAP + 0.285*LEGEND_FZ)
        .style('font-size', `${LEGEND_FZ}px`).text('Statewide');

  function drawLabels(series, isFW){
    labelYears.forEach(yr => {
      const val = getValueAt(series, yr);
      if(val != null){
        const cx = x(yr), cy = y(val) - (isFW ? LABEL_OFF_FW : LABEL_OFF_SW);
        if(isFW){
          const g = overlayG.append('g').attr('class','label-fw');
          const t = g.append('text')
            .attr('x', cx).attr('y', cy)
            .attr('text-anchor','middle')
            .style('font-size', `${LABEL_FZ}px`)
            .text(formatCompact(val, COMPACT_OPTS));
          const bb = t.node().getBBox();
          g.insert('rect','text')
            .attr('x', bb.x - PILL_PAD_X)
            .attr('y', bb.y - PILL_PAD_Y)
            .attr('width', bb.width + 2*PILL_PAD_X)
            .attr('height', bb.height + 2*PILL_PAD_Y)
            .attr('rx', PILL_RX)
            .attr('ry', PILL_RX);
        } else {
          overlayG.append('text')
            .attr('class','label-sw')
            .attr('x', cx).attr('y', cy)
            .attr('text-anchor','middle')
            .style('font-size', `${LABEL_FZ}px`)
            .text(formatCompact(val, COMPACT_OPTS));
        }
      }
    });
  }
  drawLabels(fwSeries, true);
  drawLabels(swSeries, false);
  
  function compactRoundValue(n, opts = COMPACT_OPTS) {
  if (n == null || !isFinite(n)) return NaN;

  const { rawMaxDecimals = 2, kDecimals = 1, mDecimals = 1, bDecimals = 0 } = opts;
  const abs = Math.abs(n);
  const sign = n < 0 ? -1 : 1;

  const roundTo = (val, decimals) => {
    const f = Math.pow(10, decimals);
    return Math.round(val * f) / f;
  };

  if (abs < 1_000) {
    if (Number.isInteger(n)) return n;                 // keep integers
    return sign * roundTo(abs, rawMaxDecimals);        // match raw decimals
  }
  if (abs < 1_000_000) return sign * roundTo(abs / 1e3, kDecimals) * 1e3; // K
  if (abs < 1_000_000_000) return sign * roundTo(abs / 1e6, mDecimals) * 1e6; // M
  return sign * roundTo(abs / 1e9, bDecimals) * 1e9;   // B
}

function pctChangeRounded(series, y0, y1, opts = COMPACT_OPTS) {
  const v0raw = getValueAt(series, y0);
  const v1raw = getValueAt(series, y1);

  const v0 = compactRoundValue(v0raw, opts);
  const v1 = compactRoundValue(v1raw, opts);

  if (!isFinite(v0) || !isFinite(v1) || v0 === 0) return null; // avoid div-by-zero
  return ((v1 - v0) / Math.abs(v0)) * 100;
}

function drawGrowth(series){
  const g1 = pctChangeRounded(series, 2000, 2024, COMPACT_OPTS);
  const g2 = pctChangeRounded(series, 2024, 2050, COMPACT_OPTS);

  const mid1 = (2000 + 2024) / 2;
  const mid2 = (2024 + 2050) / 2;

  // For positioning, you can keep the true mid value for y()
  // If you want the position to also reflect rounding, swap to:
  // y(compactRoundValue(getValueAt(series, mid1), COMPACT_OPTS))
  overlayG.append('text')
    .attr('class','growth')
    .attr('x', x(mid1))
    .attr('y', y(getValueAt(series, mid1)) - GROWTH_OFF)
    .attr('text-anchor','middle')
    .style('font-size', `${GROWTH_FZ}px`)
    .text(g1 == null ? '–' : formatPercent(g1));

  overlayG.append('text')
    .attr('class','growth')
    .attr('x', x(mid2))
    .attr('y', y(getValueAt(series, mid2)) - GROWTH_OFF)
    .attr('text-anchor','middle')
    .style('font-size', `${GROWTH_FZ}px`)
    .text(g2 == null ? '–' : formatPercent(g2));
}
  drawGrowth(fwSeries);
  drawGrowth(swSeries);

  // Tooltip scaled with floor
  tooltip
    .style('font-size', `${TIP_FZ}px`)
    .style('padding', `${sz(8, 6)}px`)
    .style('border-radius', `${sz(6, 4)}px`);

// Mouse interactions
svg.on('mousemove', function(event){
  const [mx] = d3.pointer(event);
  const year = Math.round(x.invert(mx));
  const nearest = markerYears.reduce((a,b) => Math.abs(b - year) < Math.abs(a - year) ? b : a);

  const fw = getValueAt(fwSeries, nearest);
  const sw = getValueAt(swSeries, nearest);

  // Position & show the hover line at the nearest year (line is in guides layer -> behind series)
  const xYear = x(nearest);
  hoverLine
    .attr('x1', xYear)
    .attr('x2', xYear)
    .attr('y1', margin.top)
    .attr('y2', height - margin.bottom)
    .style('opacity', 1);

  if (fw != null || sw != null) {
    // 1) Set tooltip content first so we can measure it
    tooltip
      .style('display', 'block')
      .html(
        `<strong>Year ${nearest}</strong><br>
         Statewide: ${formatCompact(sw, COMPACT_OPTS)}<br>
         Fort Worth: ${formatCompact(fw, COMPACT_OPTS)}`
      );

    // 2) Measure tooltip and compute a robust placement
    var tNode = tooltip.node();
    if (!tNode) return; // safety guard if tooltip isn't found

    var tRect = tNode.getBoundingClientRect();
    var pad = 12;     // gap from cursor
    var minPad = 4;   // clamp padding from edges

    // Cross-browser page scroll offsets
    var docEl = document.documentElement;
    var scrollX = window.pageXOffset || docEl.scrollLeft || 0;
    var scrollY = window.pageYOffset || docEl.scrollTop  || 0;

    // Cursor position in page coordinates
    var pageX = (typeof event.pageX === 'number') ? event.pageX : (event.clientX + scrollX);
    var pageY = (typeof event.pageY === 'number') ? event.pageY : (event.clientY + scrollY);

    // Viewport edges in page coordinates
    var viewportLeft   = scrollX;
    var viewportRight  = scrollX + (window.innerWidth  || docEl.clientWidth  || 0);
    var viewportTop    = scrollY;
    var viewportBottom = scrollY + (window.innerHeight || docEl.clientHeight || 0);

    // Decide whether to place tooltip left of cursor (if not enough room on the right)
    var placeLeft = (pageX + pad + tRect.width > viewportRight);

    // Preferred positions
    var left = placeLeft ? (pageX - tRect.width - pad) : (pageX + pad);
    var top  = pageY - Math.round(tRect.height / 2); // vertically center around cursor

    // Clamp within viewport
    if (left < viewportLeft + minPad) {
      left = viewportLeft + minPad;
    } else if (left + tRect.width > viewportRight - minPad) {
      left = viewportRight - tRect.width - minPad;
    }
    if (top < viewportTop + minPad) {
      top = viewportTop + minPad;
    } else if (top + tRect.height > viewportBottom - minPad) {
      top = viewportBottom - tRect.height - minPad;
    }

    // 3) Apply final position
    tooltip
      .style('left', left + 'px')
      .style('top',  top  + 'px');

  } else {
    tooltip.style('display','none');
  }
}).on('mouseleave', () => {
  tooltip.style('display','none');
  hoverLine.style('opacity', 0);
});

}

// Load once; re-render on resize without re-fetching
let cached = null;
d3.csv(url).then(data => { cached = data; render(cached); });
window.addEventListener('resize', () => { if (cached) render(cached); });
</script>
</body>
</html>
